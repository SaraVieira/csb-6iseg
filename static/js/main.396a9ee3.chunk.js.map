{"version":3,"sources":["Util.js","App.js","index.js"],"names":["TorusKnotHelper","u","p","q","radius","position","cu","Math","cos","su","sin","quOverP","cs","x","y","z","tubularSegments","P","THREE","points","i","PI","calculatePositionOnCurve","push","clone","generatePoints","App","concurrent","style","background","camera","fov","resize","polyfill","ResizeObserver","Scene","fallback","OrbitControls","autoRotate","autoRotateSpeed","Environment","preset","CurvyPencil","speed","debug","props","useMemo","curve","generateCurve","getPoints","flowRef","useRef","useFrame","_","delta","current","moveAlongCurve","CurveModifier","ref","Pencil","LineLoop","color","forwardRef","useGLTF","nodes","mesh","material","geometry","useLayoutEffect","scale","args","useUpdate","geom","setFromPoints","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.396a9ee3.chunk.js","sourcesContent":["import * as THREE from 'three'\r\n\r\n// Adapted from https://github.com/mrdoob/three.js/blob/master/src/geometries/TorusKnotBufferGeometry.js\r\n\r\nexport class TorusKnotHelper {\r\n  static calculatePositionOnCurve(u, p, q, radius, position) {\r\n    const cu = Math.cos(u)\r\n    const su = Math.sin(u)\r\n    const quOverP = (q / p) * u\r\n    const cs = Math.cos(quOverP)\r\n\r\n    position.x = radius * (2 + cs) * 0.5 * cu\r\n    position.y = radius * (2 + cs) * su * 0.5\r\n    position.z = radius * Math.sin(quOverP) * 0.5\r\n  }\r\n  static generatePoints(radius = 1, tubularSegments = 64, p = 2, q = 3) {\r\n    // Returns array of Vector3, no duplicates\r\n    const P = new THREE.Vector3()\r\n    const points = []\r\n    for (let i = 0; i < tubularSegments; ++i) {\r\n      // the radian \"u\" is used to calculate the position on the torus curve of the current tubular segement\r\n\r\n      const u = (i / tubularSegments) * p * Math.PI * 2\r\n\r\n      // now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.\r\n      // these points are used to create a special \"coordinate space\", which is necessary to calculate the correct vertex positions\r\n\r\n      TorusKnotHelper.calculatePositionOnCurve(u, p, q, radius, P)\r\n      points.push(P.clone())\r\n    }\r\n    return points\r\n  }\r\n  static generateCurve(...args) {\r\n    return new THREE.CatmullRomCurve3(TorusKnotHelper.generatePoints(...args), true)\r\n  }\r\n}\r\n","import React, { forwardRef, Suspense, useLayoutEffect, useMemo, useRef } from 'react'\r\nimport { Canvas, useFrame, useUpdate } from 'react-three-fiber'\r\nimport { OrbitControls, Environment, useGLTF, CurveModifier } from '@react-three/drei'\r\nimport { ResizeObserver } from '@juggle/resize-observer'\r\nimport { TorusKnotHelper } from './Util'\r\n\r\n/* \r\nModel by Alex Sanches:  https://skfb.ly/6VoNE\r\n\r\nInspirations:\r\nhttps://www.reddit.com/r/blender/comments/j87ivi/endless_possibilities/\r\nhttps://www.reddit.com/r/blender/comments/kgryl9/here_is_a_little_looping_animation_i_did_pretty/\r\n*/\r\n\r\nexport default function App() {\r\n  const style = { background: 'radial-gradient(gold, orange)' }\r\n  const camera = { position: [10, 0, 0], fov: 30 }\r\n  return (\r\n    <Canvas concurrent style={style} camera={camera} resize={{ polyfill: ResizeObserver }}>\r\n      <Scene />\r\n    </Canvas>\r\n  )\r\n}\r\n\r\nfunction Scene() {\r\n  return (\r\n    <Suspense fallback={null}>\r\n      <OrbitControls autoRotate autoRotateSpeed={(-60 * 0.15) / 2} />\r\n      <Environment preset=\"warehouse\" />\r\n      <CurvyPencil p={3} q={4} speed={0.15} />\r\n    </Suspense>\r\n  )\r\n}\r\n\r\nfunction CurvyPencil({ radius = 1, tubularSegments = 64, p = 2, q = 3, debug = false, speed = 0.2, ...props }) {\r\n  const { curve, points } = useMemo(() => {\r\n    const curve = TorusKnotHelper.generateCurve(radius, tubularSegments, p, q)\r\n    const points = curve.getPoints(300)\r\n    return { curve, points }\r\n  }, [radius, tubularSegments, p, q])\r\n  const flowRef = useRef()\r\n  useFrame((_, delta) => {\r\n    flowRef.current && flowRef.current.moveAlongCurve(delta * speed)\r\n  })\r\n  return (\r\n    <group {...props}>\r\n      <CurveModifier ref={flowRef} curve={curve}>\r\n        <Pencil />\r\n      </CurveModifier>\r\n      {debug && <LineLoop points={points} color=\"red\" />}\r\n    </group>\r\n  )\r\n}\r\n\r\n// CurveModifier needs to pass a ref, so we forwardRef\r\nconst Pencil = forwardRef((props, ref) => {\r\n  const { nodes } = useGLTF('pencil.glb')\r\n  const { material, geometry } = nodes.mesh\r\n  useLayoutEffect(() => {\r\n    geometry.scale(7, 7, 7)\r\n  }, [geometry])\r\n  return <mesh ref={ref} args={[geometry, material]} {...props} />\r\n})\r\n\r\nfunction LineLoop({ color = 'white', points = [], ...props }) {\r\n  const ref = useUpdate((geom) => geom.setFromPoints(points), [points])\r\n  return (\r\n    <lineLoop {...props}>\r\n      <bufferGeometry ref={ref} />\r\n      <lineBasicMaterial color={color} />\r\n    </lineLoop>\r\n  )\r\n}\r\n","import React from 'react'\nimport ReactDOM from 'react-dom'\nimport './styles.css'\nimport App from './App'\n\nReactDOM.render(<App />, document.getElementById('root'))\n"],"sourceRoot":""}